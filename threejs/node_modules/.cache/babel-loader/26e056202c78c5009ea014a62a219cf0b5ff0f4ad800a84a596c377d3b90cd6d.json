{"ast":null,"code":"import { Color, Matrix4, Mesh, PerspectiveCamera, Plane, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget, HalfFloatType, NoToneMapping, LinearSRGBColorSpace } from 'three';\nclass Reflector extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    this.isReflector = true;\n    this.type = 'Reflector';\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader;\n    const multisample = options.multisample !== undefined ? options.multisample : 4;\n\n    //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      name: shader.name !== undefined ? shader.name : 'unspecified',\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n\n      // Render\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputColorSpace = renderer.outputColorSpace;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false; // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n      renderer.outputColorSpace = LinearSRGBColorSpace;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputColorSpace = currentOutputColorSpace;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n\n      // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n}\nReflector.ReflectorShader = {\n  name: 'ReflectorShader',\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n};\nexport { Reflector };","map":{"version":3,"names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","HalfFloatType","NoToneMapping","LinearSRGBColorSpace","Reflector","constructor","geometry","options","arguments","length","undefined","isReflector","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","name","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentOutputColorSpace","outputColorSpace","currentToneMapping","toneMapping","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose"],"sources":["/Users/edwin.youngchan.park/Documents/sparta/inocamp/03주특기/InocamReactPrec/threejs/node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType,\n\tNoToneMapping,\n\tLinearSRGBColorSpace\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isReflector = true;\n\n\t\tthis.type = 'Reflector';\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = this.camera;\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\tconst currentOutputColorSpace = renderer.outputColorSpace;\n\t\t\tconst currentToneMapping = renderer.toneMapping;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\t\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.outputColorSpace = currentOutputColorSpace;\n\t\t\trenderer.toneMapping = currentToneMapping;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.ReflectorShader = {\n\n\tname: 'ReflectorShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n};\n\nexport { Reflector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}