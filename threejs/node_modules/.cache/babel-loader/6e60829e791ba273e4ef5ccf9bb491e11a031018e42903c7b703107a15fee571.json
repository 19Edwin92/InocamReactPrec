{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3 } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\nclass EdgeSplitModifier {\n  modify(geometry, cutOffAngle) {\n    let tryKeepNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    function computeNormals() {\n      normals = new Float32Array(indexes.length * 3);\n      for (let i = 0; i < indexes.length; i += 3) {\n        let index = indexes[i];\n        _A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        index = indexes[i + 1];\n        _B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        index = indexes[i + 2];\n        _C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        _C.sub(_B);\n        _A.sub(_B);\n        const normal = _C.cross(_A).normalize();\n        for (let j = 0; j < 3; j++) {\n          normals[3 * (i + j)] = normal.x;\n          normals[3 * (i + j) + 1] = normal.y;\n          normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    }\n    function mapPositionsToIndexes() {\n      pointToIndexMap = Array(positions.length / 3);\n      for (let i = 0; i < indexes.length; i++) {\n        const index = indexes[i];\n        if (pointToIndexMap[index] == null) {\n          pointToIndexMap[index] = [];\n        }\n        pointToIndexMap[index].push(i);\n      }\n    }\n    function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n      _A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (const j of indexes) {\n        if (j !== firstIndex) {\n          _B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n          if (_B.dot(_A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    }\n    function edgeSplit(indexes, cutOff) {\n      let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (indexes.length === 0) return;\n      const groupResults = [];\n      for (const index of indexes) {\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (const groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        splitIndexes.push({\n          original: original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    }\n    let hadNormals = false;\n    let oldNormals = null;\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n      if (tryKeepNormals === true && geometry.index !== null) {\n        oldNormals = geometry.attributes.normal.array;\n      }\n      geometry.deleteAttribute('normal');\n    }\n    if (geometry.index == null) {\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n    const indexes = geometry.index.array;\n    const positions = geometry.getAttribute('position').array;\n    let normals;\n    let pointToIndexMap;\n    computeNormals();\n    mapPositionsToIndexes();\n    const splitIndexes = [];\n    for (const vertexIndexes of pointToIndexMap) {\n      edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n    }\n    const newAttributes = {};\n    for (const name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name];\n      const newArray = new oldAttribute.array.constructor((indexes.length + splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n    const newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n    for (let i = 0; i < splitIndexes.length; i++) {\n      const split = splitIndexes[i];\n      const index = indexes[split.original];\n      for (const attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n      for (const j of split.indexes) {\n        newIndexes[j] = indexes.length + i;\n      }\n    }\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    for (const name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name]);\n    }\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n      if (oldNormals !== null) {\n        const changedNormals = new Array(oldNormals.length / 3).fill(false);\n        for (const splitData of splitIndexes) changedNormals[splitData.original] = true;\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) geometry.attributes.normal.array[3 * i + j] = oldNormals[3 * i + j];\n          }\n        }\n      }\n    }\n    return geometry;\n  }\n}\nexport { EdgeSplitModifier };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","_A","_B","_C","EdgeSplitModifier","modify","geometry","cutOffAngle","tryKeepNormals","arguments","length","undefined","computeNormals","normals","Float32Array","indexes","i","index","set","positions","sub","normal","cross","normalize","j","x","y","z","mapPositionsToIndexes","pointToIndexMap","Array","push","edgeSplitToGroups","cutOff","firstIndex","result","splitGroup","currentGroup","dot","edgeSplit","original","groupResults","groupResult","splitIndexes","hadNormals","oldNormals","attributes","clone","array","deleteAttribute","mergeVertices","getAttribute","vertexIndexes","Math","cos","newAttributes","name","Object","keys","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"sources":["/Users/edwin.youngchan.park/Documents/sparta/inocamp/03주특기/InocamReactPrec/threejs/node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\n\nclass EdgeSplitModifier {\n\n\tmodify( geometry, cutOffAngle, tryKeepNormals = true ) {\n\n\t\tfunction computeNormals() {\n\n\t\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\t\tlet index = indexes[ i ];\n\n\t\t\t\t_A.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 1 ];\n\t\t\t\t_B.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 2 ];\n\t\t\t\t_C.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\t_C.sub( _B );\n\t\t\t\t_A.sub( _B );\n\n\t\t\t\tconst normal = _C.cross( _A ).normalize();\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction mapPositionsToIndexes() {\n\n\t\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\tconst index = indexes[ i ];\n\n\t\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\t\t_A.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\t\tconst result = {\n\t\t\t\tsplitGroup: [],\n\t\t\t\tcurrentGroup: [ firstIndex ]\n\t\t\t};\n\n\t\t\tfor ( const j of indexes ) {\n\n\t\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\t\t_B.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\t\tif ( _B.dot( _A ) < cutOff ) {\n\n\t\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\t\tif ( indexes.length === 0 ) return;\n\n\t\t\tconst groupResults = [];\n\n\t\t\tfor ( const index of indexes ) {\n\n\t\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t\t}\n\n\t\t\tlet result = groupResults[ 0 ];\n\n\t\t\tfor ( const groupResult of groupResults ) {\n\n\t\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\t\tresult = groupResult;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( original != null ) {\n\n\t\t\t\tsplitIndexes.push( {\n\t\t\t\t\toriginal: original,\n\t\t\t\t\tindexes: result.currentGroup\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( result.splitGroup.length ) {\n\n\t\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet hadNormals = false;\n\t\tlet oldNormals = null;\n\n\t\tif ( geometry.attributes.normal ) {\n\n\t\t\thadNormals = true;\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t\tif ( tryKeepNormals === true && geometry.index !== null ) {\n\n\t\t\t\toldNormals = geometry.attributes.normal.array;\n\n\t\t\t}\n\n\t\t\tgeometry.deleteAttribute( 'normal' );\n\n\t\t}\n\n\t\tif ( geometry.index == null ) {\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tconst indexes = geometry.index.array;\n\t\tconst positions = geometry.getAttribute( 'position' ).array;\n\n\t\tlet normals;\n\t\tlet pointToIndexMap;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\t\tconst splitIndexes = [];\n\n\t\tfor ( const vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tconst newAttributes = {};\n\t\tfor ( const name of Object.keys( geometry.attributes ) ) {\n\n\t\t\tconst oldAttribute = geometry.attributes[ name ];\n\t\t\tconst newArray = new oldAttribute.array.constructor( ( indexes.length + splitIndexes.length ) * oldAttribute.itemSize );\n\t\t\tnewArray.set( oldAttribute.array );\n\t\t\tnewAttributes[ name ] = new BufferAttribute( newArray, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t}\n\n\t\tconst newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( let i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tconst split = splitIndexes[ i ];\n\t\t\tconst index = indexes[ split.original ];\n\n\t\t\tfor ( const attribute of Object.values( newAttributes ) ) {\n\n\t\t\t\tfor ( let j = 0; j < attribute.itemSize; j ++ ) {\n\n\t\t\t\t\tattribute.array[ ( indexes.length + i ) * attribute.itemSize + j ] =\n\t\t\t\t\t\tattribute.array[ index * attribute.itemSize + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = indexes.length + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\tfor ( const name of Object.keys( newAttributes ) ) {\n\n\t\t\tgeometry.setAttribute( name, newAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( hadNormals ) {\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tif ( oldNormals !== null ) {\n\n\t\t\t\tconst changedNormals = new Array( oldNormals.length / 3 ).fill( false );\n\n\t\t\t\tfor ( const splitData of splitIndexes )\n\t\t\t\t\tchangedNormals[ splitData.original ] = true;\n\n\t\t\t\tfor ( let i = 0; i < changedNormals.length; i ++ ) {\n\n\t\t\t\t\tif ( changedNormals[ i ] === false ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ )\n\t\t\t\t\t\t\tgeometry.attributes.normal.array[ 3 * i + j ] = oldNormals[ 3 * i + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n\n\nexport { EdgeSplitModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}